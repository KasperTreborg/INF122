evaluate :: (Num number, Ranged cell)
         => Sheet number cell
         -> Expression number cell
         -> Maybe number
evaluate sheet expr = evaluateWithVisited sheet expr Set.empty
    where
      evaluateWithVisited :: (Num number, Ranged cell) => Sheet number cell -> Expression number cell -> Set cell -> Maybe number
      evaluateWithVisited _ _ visited | Set.null visited = Nothing
      evaluateWithVisited _ (Ref cell) visited
        | cell `Set.member` visited = Nothing
      evaluateWithVisited _ (Constant n) _ = Just n
      evaluateWithVisited sheet (Sum range) visited = evaluateSum sheet range
      evaluateWithVisited sheet (Add left right) visited = do
        leftValue <- evaluateWithVisited sheet left visited
        rightValue <- evaluateWithVisited sheet right visited
        return (leftValue + rightValue)
      evaluateWithVisited sheet (Mul left right) visited = do
        leftValue <- evaluateWithVisited sheet left visited
        rightValue <- evaluateWithVisited sheet right visited
        return (leftValue * rightValue)




evaluate :: (Num number, Ranged cell)
         => Sheet number cell
         -> Expression number cell
         -> Maybe number
evaluate sheet expr =
    case expr of
      Ref cell -> evaluateReference sheet cell
      Constant n -> Just n
      Sum range -> evaluateSum sheet range
      Add left right -> do
        leftValue <- evaluate sheet left
        rightValue <- evaluate sheet right
        return (leftValue + rightValue)
      Mul leftExpr rightExpr -> do
        leftValue <- evaluate sheet leftExpr
        rightValue <- evaluate sheet rightExpr
        return (leftValue * rightValue)
    where
      evaluateReference :: (Num number, Ranged cell) => Sheet number cell -> cell -> Maybe number
      evaluateReference sheet cell =
        case Map.lookup cell (content sheet) of
          Just expr -> evaluate sheet expr
          Nothing -> Nothing

      evaluateSum :: (Num number, Ranged cell) => Sheet number cell -> CellRange cell -> Maybe number
      evaluateSum sheet range =
        let cells = cellRange (dimension sheet) range
        in do
          values <- sequence [evaluateReference sheet cell | cell <- Set.toList cells]
          return (sum values)

evaluate :: (Num number, Ranged cell) => Sheet number cell -> Expression number cell -> Maybe number
evaluate sheet expr = 
      evaluateNoCircles sheet expr Set.empty

evaluateNoCircles :: (Num number, Ranged cell) => Sheet number cell -> Expression number cell -> Set cell -> Maybe number
evaluateNoCircles sheet expr visited = case expr of
        Ref cell -> 
          if Set.member cell visited
            then Nothing
          else refEvaluate sheet cell visited
        Constant number -> Just number
        Sum range -> sumEvaluate sheet range visited
        Add expr1 expr2 -> do
          cell1 <- evaluateNoCircles sheet expr1 visited
          cell2 <- evaluateNoCircles sheet expr2 visited
          return (cell1 + cell2)
        Mul expr1 expr2 -> do
          cell1 <- evaluateNoCircles sheet expr1 visited
          cell2 <- evaluateNoCircles sheet expr2 visited
          return (cell1 * cell2)

sumEvaluate :: (Num number, Ranged cell) => Sheet number cell -> CellRange cell -> Set cell -> Maybe number
sumEvaluate sheet range visited =
  let cells = cellRange (dimension sheet) range
  in do
    values <- sequence [refEvaluate sheet cell (Set.insert cell visited) | cell <- Set.toList cells]
    return (sum values)

refEvaluate :: (Num number, Ranged cell) => Sheet number cell -> cell -> Set cell -> Maybe number
refEvaluate sheet cell visited =
  if Set.member cell visited
    then Nothing 
  else case Map.lookup cell (content sheet) of
    Just expr -> evaluateNoCircles sheet expr (Set.insert cell visited)
    Nothing -> Nothing